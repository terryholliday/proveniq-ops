# ============================================================================
# BISHOP DECISION DAG - AUTHORITATIVE SOURCE OF TRUTH
# ============================================================================
#
# This file defines the complete decision graph for Bishop.
# Code MUST conform to this file — not the other way around.
#
# THE ONE RULE:
#   Signals detect. Policy decides. Proposals package.
#   Approvals authorize. Execution commits. Telemetry proves.
#
# Rules:
#   - If logic is not declared here → it's invalid code
#   - Nodes run ONLY when upstream dependencies are satisfied
#   - No side effects unless explicitly declared
#   - All outputs are typed contracts
#
# Layer Structure:
#   N0-N4:   Canonical Data Contracts (versioned snapshots)
#   N10-N18: Signals (pure detection, no actions)
#   N20-N25: Policy Gates (gates + prioritization)
#   N30-N37: Proposals (build actions, no execution)
#   N40-N46: Execution (explicit approvals only)
#   N50-N52: Telemetry (accounting + moat metrics)
#
# ============================================================================

version: "2.0"
schema_version: 2
last_updated: "2024-12-18"
owner: "Bishop Core Team"

# ============================================================================
# LAYER 0: CANONICAL DATA CONTRACTS (N0-N4)
# Must exist before anything else.
# All outputs are versioned, typed, and reproducible from DB rows.
# Every downstream node references these outputs ONLY (no direct table access).
# ============================================================================

nodes:
  # --------------------------------------------------------------------------
  # N0: Identity & Context
  # --------------------------------------------------------------------------
  N0_identity_context:
    layer: 0
    name: "Identity & Context"
    description: "User identity, location, org, role, and permissions context"
    depends_on: []
    inputs:
      - user_id
      - location_id
      - org_id
      - role
      - permissions
    outputs:
      - name: ctx
        type: "Context"
        schema:
          user_id: uuid
          location_id: uuid
          org_id: uuid
          role: string
          permissions: string[]
          session_id: uuid
          timestamp: datetime
    invariants:
      - "user_id != null"
      - "org_id != null"
    side_effects: none
    cacheable: true
    ttl_seconds: 3600

  # --------------------------------------------------------------------------
  # N1: Inventory State Snapshot
  # --------------------------------------------------------------------------
  N1_inventory_snapshot:
    layer: 0
    name: "Inventory State Snapshot"
    description: "Current inventory levels with reserved quantities and open PO context"
    depends_on: []
    inputs:
      - inventory_levels
      - reserved_qty
      - open_pos
      - lot_state
    outputs:
      - name: inv_snapshot
        type: "InventorySnapshot"
        schema:
          snapshot_id: uuid
          snapshot_version: integer
          timestamp: datetime
          items:
            product_id: uuid
            location_id: uuid
            on_hand_qty: integer
            reserved_qty: integer
            available_qty: integer
            safety_stock: integer
            lot_id: uuid?
            expiry_date: datetime?
          open_po_summary:
            total_incoming: integer
            expected_dates: datetime[]
    invariants:
      - "available_qty == on_hand_qty - reserved_qty"
      - "on_hand_qty >= 0"
      - "reserved_qty >= 0"
    side_effects: none
    cacheable: true
    ttl_seconds: 300
    reproducible_from: "inventory_levels, reservations, purchase_orders, lots"

  # --------------------------------------------------------------------------
  # N2: Scan Stream Normalization
  # --------------------------------------------------------------------------
  N2_scan_normalization:
    layer: 0
    name: "Scan Stream Normalization"
    description: "Deduped, time-normalized, unit-normalized, user-attributed scan facts"
    depends_on: []
    inputs:
      - raw_scan_events
    outputs:
      - name: scan_facts
        type: "ScanFact[]"
        schema:
          fact_id: uuid
          product_id: uuid
          location_id: uuid
          qty_delta: integer
          normalized_qty: decimal
          unit_of_measure: string
          scan_type: enum[consumption, receiving, adjustment, transfer, spoilage]
          user_id: uuid
          device_id: string?
          timestamp: datetime
          confidence: decimal
          dedup_key: string
    invariants:
      - "no duplicate dedup_keys within 60s window"
      - "timestamp <= now()"
      - "confidence >= 0 AND confidence <= 1"
    side_effects: none
    cacheable: true
    ttl_seconds: 60
    reproducible_from: "scan_events"

  # --------------------------------------------------------------------------
  # N3: Vendor SKU Normalization
  # --------------------------------------------------------------------------
  N3_sku_normalization:
    layer: 0
    name: "Vendor SKU Normalization"
    description: "Canonical SKU graph mapping vendor-specific SKUs to internal products"
    depends_on: []
    inputs:
      - vendor_feeds
      - mapping_table
    outputs:
      - name: sku_xref
        type: "SKUCrossReference"
        schema:
          canonical_sku: string
          product_id: uuid
          product_name: string
          vendor_mappings:
            vendor_id: uuid
            vendor_sku: string
            vendor_name: string
            current_price: decimal
            stock_available: integer?
            lead_time_hours: integer
            reliability_score: decimal
            last_synced: datetime
          substitutes: uuid[]
          category: string
    invariants:
      - "each vendor_sku maps to exactly one canonical_sku"
      - "current_price > 0"
      - "reliability_score >= 0 AND reliability_score <= 1"
    side_effects: none
    cacheable: true
    ttl_seconds: 1800
    reproducible_from: "vendor_products, sku_mappings, vendors"

  # --------------------------------------------------------------------------
  # N4: Ledger Liquidity Snapshot
  # --------------------------------------------------------------------------
  N4_liquidity_snapshot:
    layer: 0
    name: "Ledger Liquidity Snapshot"
    description: "Current cash position with obligations from PROVENIQ Ledger"
    depends_on: []
    inputs:
      - ledger_balances
      - obligations
    outputs:
      - name: liquidity_state
        type: "LiquidityState"
        schema:
          snapshot_id: uuid
          timestamp: datetime
          available_balance: decimal
          reserved_balance: decimal
          pending_obligations: decimal
          net_available: decimal
          currency: string
          credit_limit: decimal?
          credit_used: decimal?
    invariants:
      - "net_available == available_balance - reserved_balance - pending_obligations"
      - "available_balance >= 0"
    side_effects: none
    cacheable: false
    ttl_seconds: 0
    reproducible_from: "ledger_accounts, ledger_obligations"

# ============================================================================
# LAYER 1: SIGNALS (N10-N18)
# Pure detection — no actions.
# Signals are idempotent (same inputs ⇒ same outputs).
# No node here can create orders, transfers, or ledger entries.
# ============================================================================

  # --------------------------------------------------------------------------
  # N10: Burn Rate + Forecast Facts
  # --------------------------------------------------------------------------
  N10_demand_forecast:
    layer: 1
    name: "Burn Rate + Forecast Facts"
    description: "Historical usage aggregation with burn rate and velocity metrics"
    depends_on:
      - N1_inventory_snapshot
      - N2_scan_normalization
    inputs:
      - inv_snapshot
      - scan_facts
    outputs:
      - name: demand_forecast
        type: "DemandForecast[]"
        schema:
          product_id: uuid
          location_id: uuid
          avg_daily_burn_7d: decimal
          avg_daily_burn_30d: decimal
          avg_daily_burn_90d: decimal
          current_velocity: decimal
          velocity_trend: enum[accelerating, stable, decelerating]
          variance_coefficient: decimal
          seasonality_factor: decimal?
          confidence: decimal
          calculated_at: datetime
    invariants:
      - "confidence >= 0 AND confidence <= 1"
      - "avg_daily_burn_7d >= 0"
      - "avg_daily_burn_30d >= 0"
      - "avg_daily_burn_90d >= 0"
    side_effects: none
    cacheable: true
    ttl_seconds: 300
    idempotent: true

  # --------------------------------------------------------------------------
  # N11: Stockout Risk Detector
  # --------------------------------------------------------------------------
  N11_stockout_risk:
    layer: 1
    name: "Stockout Risk Detector"
    description: "Predictive stockout detection with hours-to-stockout projection"
    depends_on:
      - N10_demand_forecast
      - N3_sku_normalization
    inputs:
      - demand_forecast
      - sku_xref
    outputs:
      - name: stockout_risks
        type: "StockoutRisk[]"
        schema:
          risk_id: uuid
          product_id: uuid
          location_id: uuid
          current_qty: integer
          safety_stock: integer
          hours_to_stockout: decimal
          hours_to_safety_breach: decimal
          best_vendor_lead_time: integer
          confidence: decimal
          severity: enum[low, medium, high, critical]
          detected_at: datetime
    invariants:
      - "hours_to_stockout >= 0"
      - "confidence >= 0.6 OR severity == 'low'"
      - "severity == 'critical' IMPLIES hours_to_stockout <= 12"
    side_effects: none
    cacheable: true
    ttl_seconds: 300
    idempotent: true

  # --------------------------------------------------------------------------
  # N12: Ghost Inventory Detector
  # --------------------------------------------------------------------------
  N12_ghost_inventory:
    layer: 1
    name: "Ghost Inventory Detector"
    description: "Detect items in system but not scanned within expected window"
    depends_on:
      - N1_inventory_snapshot
      - N2_scan_normalization
    inputs:
      - inv_snapshot
      - scan_facts
    outputs:
      - name: ghost_flags
        type: "GhostFlag[]"
        schema:
          flag_id: uuid
          product_id: uuid
          location_id: uuid
          system_qty: integer
          days_since_last_scan: integer
          expected_scan_frequency_days: integer
          variance_value: decimal
          confidence: decimal
          detected_at: datetime
    invariants:
      - "days_since_last_scan > expected_scan_frequency_days"
      - "system_qty > 0"
    side_effects: none
    cacheable: true
    ttl_seconds: 3600
    idempotent: true

  # --------------------------------------------------------------------------
  # N13: Expiration Windows Detector
  # --------------------------------------------------------------------------
  N13_expiration_risk:
    layer: 1
    name: "Expiration Windows Detector"
    description: "Track expiring inventory in 24/48/72h buckets with loss estimation"
    depends_on:
      - N1_inventory_snapshot
    inputs:
      - inv_snapshot
    outputs:
      - name: expiry_flags
        type: "ExpiryFlag[]"
        schema:
          flag_id: uuid
          product_id: uuid
          location_id: uuid
          lot_id: uuid?
          quantity: integer
          expiry_date: datetime
          hours_to_expiry: integer
          bucket: enum[expired, 24h, 48h, 72h, 7d, safe]
          unit_cost: decimal
          estimated_loss: decimal
          risk_level: enum[none, low, medium, high, critical]
          detected_at: datetime
    invariants:
      - "bucket == 'expired' IMPLIES hours_to_expiry <= 0"
      - "bucket == 'critical' IMPLIES hours_to_expiry <= 24"
      - "estimated_loss == quantity * unit_cost"
    side_effects: none
    cacheable: true
    ttl_seconds: 3600
    idempotent: true

  # --------------------------------------------------------------------------
  # N14: Price Delta Detector
  # --------------------------------------------------------------------------
  N14_price_delta:
    layer: 1
    name: "Price Delta Detector"
    description: "Cross-vendor price comparison for equivalent SKUs"
    depends_on:
      - N3_sku_normalization
    inputs:
      - sku_xref
    outputs:
      - name: price_deltas
        type: "PriceDelta[]"
        schema:
          delta_id: uuid
          canonical_sku: string
          product_id: uuid
          current_vendor_id: uuid
          current_vendor_name: string
          current_price: decimal
          best_vendor_id: uuid
          best_vendor_name: string
          best_price: decimal
          delta_amount: decimal
          delta_percent: decimal
          annual_savings_estimate: decimal
          detected_at: datetime
    invariants:
      - "delta_percent == (current_price - best_price) / current_price * 100"
      - "delta_amount == current_price - best_price"
      - "delta_percent > 0"
    side_effects: none
    cacheable: true
    ttl_seconds: 1800
    idempotent: true

  # --------------------------------------------------------------------------
  # N15: Scan Anomaly Detector
  # --------------------------------------------------------------------------
  N15_scan_anomaly:
    layer: 1
    name: "Scan Anomaly Detector"
    description: "Detect unusual scan patterns for loss prevention"
    depends_on:
      - N2_scan_normalization
    inputs:
      - scan_facts
      - historical_norms
    outputs:
      - name: scan_anomalies
        type: "ScanAnomaly[]"
        schema:
          anomaly_id: uuid
          product_id: uuid
          location_id: uuid
          user_id: uuid?
          anomaly_type: enum[volume_spike, off_hours, repeated_scan, pattern_deviation, velocity_spike]
          severity: enum[low, medium, high]
          reason: string
          evidence:
            scan_count: integer
            time_window: string
            deviation_factor: decimal
          detected_at: datetime
    invariants:
      - "severity IN ['low', 'medium', 'high']"
      - "reason != null"
    side_effects: none
    cacheable: true
    ttl_seconds: 300
    idempotent: true

  # --------------------------------------------------------------------------
  # N16: Receiving Reconciliation Detector
  # --------------------------------------------------------------------------
  N16_receiving_reconciliation:
    layer: 1
    name: "Receiving Reconciliation Detector"
    description: "Scan-to-PO matching and discrepancy detection"
    depends_on:
      - N2_scan_normalization
      - N1_inventory_snapshot
      - N3_sku_normalization
    inputs:
      - scan_facts
      - inv_snapshot
      - sku_xref
    outputs:
      - name: receiving_discrepancies
        type: "ReceivingDiscrepancy[]"
        schema:
          discrepancy_id: uuid
          po_id: uuid
          po_number: string
          vendor_id: uuid
          vendor_name: string
          line_items:
            line_id: uuid
            product_id: uuid
            expected_qty: integer
            received_qty: integer
            variance: integer
            discrepancy_type: enum[short, overage, substitution, damaged, missing]
          total_lines: integer
          lines_matched: integer
          short_count: integer
          overage_count: integer
          substitution_count: integer
          damaged_count: integer
          variance_value: decimal
          detected_at: datetime
    invariants:
      - "lines_matched + short_count + overage_count + substitution_count + damaged_count <= total_lines"
    side_effects: none
    cacheable: false
    ttl_seconds: 0
    idempotent: true

  # --------------------------------------------------------------------------
  # N17: Cost-Per-Serving Facts
  # --------------------------------------------------------------------------
  N17_menu_cost:
    layer: 1
    name: "Cost-Per-Serving Facts"
    description: "Real-time cost-per-plate as ingredient prices fluctuate"
    depends_on:
      - N1_inventory_snapshot
    inputs:
      - inv_snapshot
      - recipe_mappings
    outputs:
      - name: menu_cost_facts
        type: "MenuCostFact[]"
        schema:
          fact_id: uuid
          menu_item_id: uuid
          menu_item_name: string
          current_cost: decimal
          previous_cost: decimal
          cost_change: decimal
          cost_change_percent: decimal
          current_margin: decimal
          previous_margin: decimal
          margin_compression: decimal
          ingredients:
            product_id: uuid
            quantity: decimal
            unit_cost: decimal
            cost_contribution: decimal
          calculated_at: datetime
    invariants:
      - "cost_change == current_cost - previous_cost"
      - "margin_compression == previous_margin - current_margin"
    side_effects: none
    cacheable: true
    ttl_seconds: 3600
    idempotent: true

  # --------------------------------------------------------------------------
  # N18: Multi-Location Imbalance Detector
  # --------------------------------------------------------------------------
  N18_location_imbalance:
    layer: 1
    name: "Multi-Location Imbalance Detector"
    description: "Detect overstocked locations vs stockout-risk locations"
    depends_on:
      - N1_inventory_snapshot
      - N10_demand_forecast
    inputs:
      - inv_snapshot
      - demand_forecast
    outputs:
      - name: rebalance_candidates
        type: "RebalanceCandidate[]"
        schema:
          candidate_id: uuid
          product_id: uuid
          source_location_id: uuid
          source_location_name: string
          source_excess_qty: integer
          source_days_of_stock: decimal
          dest_location_id: uuid
          dest_location_name: string
          dest_shortage_qty: integer
          dest_days_until_stockout: decimal
          recommended_transfer_qty: integer
          distance_miles: decimal?
          estimated_transfer_cost: decimal?
          detected_at: datetime
    invariants:
      - "source_excess_qty > 0"
      - "dest_shortage_qty > 0"
      - "recommended_transfer_qty <= source_excess_qty"
    side_effects: none
    cacheable: true
    ttl_seconds: 3600
    idempotent: true

# ============================================================================
# LAYER 2: POLICY GATES (N20-N25)
# All "should we do it?" decisions happen here.
# Every action downstream must reference a policy decision token.
# ============================================================================

  # --------------------------------------------------------------------------
  # N20: Policy: Liquidity Gate
  # --------------------------------------------------------------------------
  N20_liquidity_gate:
    layer: 2
    name: "Policy: Liquidity Gate"
    description: "Cash availability verification and spend limits from Ledger"
    depends_on:
      - N4_liquidity_snapshot
    inputs:
      - liquidity_state
      - proposed_spend
    outputs:
      - name: spend_policy
        type: "SpendPolicy"
        schema:
          policy_token: uuid
          allowed: boolean
          max_spend: decimal
          available_balance: decimal
          shortfall: decimal?
          deferral_rules:
            can_defer: boolean
            defer_until: datetime?
            defer_reason: string?
          blocked_reason: string?
          evaluated_at: datetime
    invariants:
      - "allowed == true IMPLIES available_balance >= proposed_spend"
      - "allowed == false IMPLIES blocked_reason != null"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N21: Policy: Item Criticality
  # --------------------------------------------------------------------------
  N21_criticality_policy:
    layer: 2
    name: "Policy: Item Criticality"
    description: "Classify items by business criticality for prioritization"
    depends_on:
      - N1_inventory_snapshot
    inputs:
      - inv_snapshot
      - criticality_config
    outputs:
      - name: criticality_map
        type: "CriticalityMap"
        schema:
          items:
            product_id: uuid
            criticality: enum[CRITICAL, HIGH, NORMAL, LOW]
            reason: string
            auto_reorder_enabled: boolean
            stockout_tolerance_hours: integer
          evaluated_at: datetime
    invariants:
      - "criticality IN ['CRITICAL', 'HIGH', 'NORMAL', 'LOW']"
    side_effects: none
    cacheable: true
    ttl_seconds: 3600

  # --------------------------------------------------------------------------
  # N22: Policy: Approval Rules
  # --------------------------------------------------------------------------
  N22_approval_policy:
    layer: 2
    name: "Policy: Approval Rules"
    description: "Define who can approve what actions and at what thresholds"
    depends_on:
      - N0_identity_context
    inputs:
      - ctx
      - action_type
      - action_value
    outputs:
      - name: approval_policy
        type: "ApprovalPolicy"
        schema:
          policy_token: uuid
          action_type: string
          action_value: decimal
          requires_approval: boolean
          required_role: string?
          required_approvers: integer
          auto_approve_threshold: decimal?
          escalation_chain: string[]
          evaluated_at: datetime
    invariants:
      - "requires_approval == true IMPLIES required_role != null"
      - "action_value > auto_approve_threshold IMPLIES requires_approval == true"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N23: Policy: Vendor Constraints
  # --------------------------------------------------------------------------
  N23_vendor_policy:
    layer: 2
    name: "Policy: Vendor Constraints"
    description: "Contract obligations, locked vendors, minimum orders"
    depends_on:
      - N3_sku_normalization
    inputs:
      - sku_xref
      - contracts
    outputs:
      - name: vendor_policy
        type: "VendorPolicy"
        schema:
          constraints:
            product_id: uuid
            locked_vendor_id: uuid?
            locked_reason: string?
            min_order_qty: integer?
            min_order_value: decimal?
            contract_exclusions: uuid[]
            rebate_eligible: boolean
          evaluated_at: datetime
    invariants:
      - "locked_vendor_id != null IMPLIES locked_reason != null"
    side_effects: none
    cacheable: true
    ttl_seconds: 3600

  # --------------------------------------------------------------------------
  # N24: Policy: Compliance & Disposition
  # --------------------------------------------------------------------------
  N24_disposition_policy:
    layer: 2
    name: "Policy: Compliance & Disposition"
    description: "Rules for donation, disposal, markdown of expiring inventory"
    depends_on: []
    inputs:
      - org_settings
      - compliance_rules
    outputs:
      - name: disposition_policy
        type: "DispositionPolicy"
        schema:
          donation_allowed: boolean
          donation_partners: string[]
          donation_tax_benefit: decimal?
          disposal_rules:
            hazardous_protocol: string
            documentation_required: boolean
            witness_required: boolean
          markdown_rules:
            max_discount_percent: decimal
            approval_threshold: decimal
          waste_autopsy_required: boolean
          evaluated_at: datetime
    invariants:
      - "donation_allowed == false IMPLIES donation_partners == []"
    side_effects: none
    cacheable: true
    ttl_seconds: 86400

  # --------------------------------------------------------------------------
  # N25: Priority Scoring (Bishop Triage)
  # --------------------------------------------------------------------------
  N25_priority_scoring:
    layer: 2
    name: "Priority Scoring (Bishop Triage)"
    description: "Rank all detected issues into prioritized worklist"
    depends_on:
      - N11_stockout_risk
      - N12_ghost_inventory
      - N13_expiration_risk
      - N14_price_delta
      - N15_scan_anomaly
      - N16_receiving_reconciliation
      - N17_menu_cost
      - N18_location_imbalance
      - N20_liquidity_gate
      - N21_criticality_policy
      - N22_approval_policy
      - N23_vendor_policy
      - N24_disposition_policy
    inputs:
      - stockout_risks
      - ghost_flags
      - expiry_flags
      - price_deltas
      - scan_anomalies
      - receiving_discrepancies
      - menu_cost_facts
      - rebalance_candidates
      - spend_policy
      - criticality_map
      - approval_policy
      - vendor_policy
      - disposition_policy
    outputs:
      - name: ranked_worklist
        type: "WorklistItem[]"
        schema:
          item_id: uuid
          source_node: string
          source_id: uuid
          priority_score: integer
          urgency: enum[immediate, today, this_week, backlog]
          category: enum[stockout, expiration, receiving, pricing, anomaly, rebalance, margin]
          recommended_path: string
          estimated_impact: decimal
          requires_approval: boolean
          policy_tokens: uuid[]
          created_at: datetime
    invariants:
      - "priority_score >= 0 AND priority_score <= 100"
      - "policy_tokens.length > 0"
    side_effects: none
    cacheable: true
    ttl_seconds: 300

# ============================================================================
# LAYER 3: PROPOSALS (N30-N37)
# Build actions — still no execution.
# Outputs are "ready-to-approve" objects with complete payloads.
# Every proposal includes: reason_codes[], estimated_impact, required_approver.
# ============================================================================

  # --------------------------------------------------------------------------
  # N30: Reorder Proposal Builder
  # --------------------------------------------------------------------------
  N30_reorder_proposal:
    layer: 3
    name: "Reorder Proposal Builder"
    description: "Build reorder recommendations from stockout risks"
    depends_on:
      - N11_stockout_risk
      - N21_criticality_policy
      - N23_vendor_policy
      - N20_liquidity_gate
    inputs:
      - stockout_risks
      - criticality_map
      - vendor_policy
      - spend_policy
    outputs:
      - name: reorder_proposals
        type: "ReorderProposal[]"
        schema:
          proposal_id: uuid
          product_id: uuid
          product_name: string
          vendor_id: uuid
          vendor_name: string
          vendor_sku: string
          quantity: integer
          unit_price: decimal
          total_cost: decimal
          eta_hours: integer
          confidence: decimal
          reason_codes: string[]
          estimated_impact:
            stockout_prevented: boolean
            days_of_coverage: decimal
          required_approver: string?
          auto_execute_eligible: boolean
          policy_tokens: uuid[]
          created_at: datetime
    invariants:
      - "quantity > 0"
      - "total_cost == quantity * unit_price"
      - "reason_codes.length > 0"
      - "auto_execute_eligible == true IMPLIES required_approver == null"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N31: Emergency Reorder Proposal
  # --------------------------------------------------------------------------
  N31_emergency_reorder:
    layer: 3
    name: "Emergency Reorder Proposal"
    description: "One-tap emergency reorder for CRITICAL stockouts"
    depends_on:
      - N11_stockout_risk
      - N21_criticality_policy
      - N23_vendor_policy
      - N20_liquidity_gate
    inputs:
      - stockout_risks
      - criticality_map
      - vendor_policy
      - spend_policy
    outputs:
      - name: emergency_orders
        type: "EmergencyOrder[]"
        schema:
          order_id: uuid
          product_id: uuid
          product_name: string
          vendor_id: uuid
          vendor_name: string
          quantity: integer
          total_cost: decimal
          eta_hours: integer
          one_tap_eligible: boolean
          one_tap_payload:
            vendor_api_endpoint: string
            order_body: object
          reason_codes: string[]
          policy_tokens: uuid[]
          created_at: datetime
    invariants:
      - "stockout_risks.severity == 'critical'"
      - "one_tap_eligible IMPLIES spend_policy.allowed == true"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N32: Receiving Adjustment Proposal
  # --------------------------------------------------------------------------
  N32_receiving_adjustment:
    layer: 3
    name: "Receiving Adjustment Proposal"
    description: "Build PO adjustment proposals from receiving discrepancies"
    depends_on:
      - N16_receiving_reconciliation
      - N22_approval_policy
    inputs:
      - receiving_discrepancies
      - approval_policy
    outputs:
      - name: po_adjustments
        type: "POAdjustment[]"
        schema:
          adjustment_id: uuid
          po_id: uuid
          po_number: string
          vendor_id: uuid
          action: enum[accept, accept_with_adjustments, dispute, reject]
          adjustments:
            line_id: uuid
            adjustment_type: enum[short_credit, overage_return, substitution_accept, damage_claim]
            quantity: integer
            value: decimal
          total_adjustment_value: decimal
          requires_confirmation: boolean
          reason_codes: string[]
          estimated_impact:
            inventory_correction: integer
            cost_recovery: decimal
          required_approver: string
          policy_tokens: uuid[]
          created_at: datetime
    invariants:
      - "requires_confirmation == true"
      - "reason_codes.length > 0"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N33: Expiration Cascade Plan
  # --------------------------------------------------------------------------
  N33_expiration_plan:
    layer: 3
    name: "Expiration Cascade Plan"
    description: "Build action plans for expiring inventory (discount/donate/dispose)"
    depends_on:
      - N13_expiration_risk
      - N24_disposition_policy
    inputs:
      - expiry_flags
      - disposition_policy
    outputs:
      - name: expiry_action_plans
        type: "ExpiryActionPlan[]"
        schema:
          plan_id: uuid
          product_id: uuid
          product_name: string
          location_id: uuid
          quantity: integer
          expiry_date: datetime
          actions:
            action_type: enum[discount, transfer, donate, dispose]
            quantity: integer
            rationale: string
          discount_plan:
            discount_percent: decimal
            markdown_value: decimal
          donation_plan:
            partner: string
            tax_benefit: decimal
          disposal_plan:
            protocol: string
            documentation_required: boolean
          estimated_loss: decimal
          estimated_recovery: decimal
          net_impact: decimal
          liability_mitigated: boolean
          reason_codes: string[]
          required_approver: string
          policy_tokens: uuid[]
          created_at: datetime
    invariants:
      - "estimated_loss >= 0"
      - "net_impact == estimated_recovery - estimated_loss"
      - "reason_codes.length > 0"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N34: Vendor Switch Proposal
  # --------------------------------------------------------------------------
  N34_vendor_switch:
    layer: 3
    name: "Vendor Switch Proposal"
    description: "Build vendor switch recommendations from price deltas"
    depends_on:
      - N14_price_delta
      - N23_vendor_policy
    inputs:
      - price_deltas
      - vendor_policy
    outputs:
      - name: vendor_switch_proposals
        type: "VendorSwitchProposal[]"
        schema:
          proposal_id: uuid
          product_id: uuid
          product_name: string
          from_vendor_id: uuid
          from_vendor_name: string
          from_price: decimal
          to_vendor_id: uuid
          to_vendor_name: string
          to_price: decimal
          switch_reason: enum[price, availability, reliability, contract]
          savings_per_unit: decimal
          annual_savings_estimate: decimal
          contract_implications: string?
          reason_codes: string[]
          estimated_impact:
            annual_savings: decimal
            lead_time_change: integer
          required_approver: string
          policy_tokens: uuid[]
          created_at: datetime
    invariants:
      - "savings_per_unit == from_price - to_price"
      - "reason_codes.length > 0"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N35: Rebalance Transfer Proposal
  # --------------------------------------------------------------------------
  N35_transfer_proposal:
    layer: 3
    name: "Rebalance Transfer Proposal"
    description: "Build inter-location transfer proposals"
    depends_on:
      - N18_location_imbalance
      - N22_approval_policy
    inputs:
      - rebalance_candidates
      - approval_policy
    outputs:
      - name: transfer_proposals
        type: "TransferProposal[]"
        schema:
          proposal_id: uuid
          product_id: uuid
          product_name: string
          source_location_id: uuid
          source_location_name: string
          dest_location_id: uuid
          dest_location_name: string
          quantity: integer
          transfer_cost: decimal
          stockout_prevented: boolean
          reason_codes: string[]
          estimated_impact:
            source_days_remaining: decimal
            dest_days_gained: decimal
          required_approver: string
          policy_tokens: uuid[]
          created_at: datetime
    invariants:
      - "quantity > 0"
      - "reason_codes.length > 0"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N36: Anomaly Review Packet
  # --------------------------------------------------------------------------
  N36_anomaly_review:
    layer: 3
    name: "Anomaly Review Packet"
    description: "Build evidence bundles for scan anomalies (not accusations)"
    depends_on:
      - N15_scan_anomaly
      - N0_identity_context
    inputs:
      - scan_anomalies
      - ctx
    outputs:
      - name: review_packets
        type: "ReviewPacket[]"
        schema:
          packet_id: uuid
          anomaly_id: uuid
          anomaly_type: string
          severity: string
          product_id: uuid
          location_id: uuid
          user_id: uuid?
          evidence:
            scan_timeline: object[]
            deviation_metrics: object
            comparison_baseline: object
          review_notes: string?
          reason_codes: string[]
          recommended_action: enum[investigate, monitor, dismiss]
          required_reviewer: string
          policy_tokens: uuid[]
          created_at: datetime
    invariants:
      - "evidence != null"
      - "reason_codes.length > 0"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N37: Margin Alert Proposal
  # --------------------------------------------------------------------------
  N37_margin_alert:
    layer: 3
    name: "Margin Alert Proposal"
    description: "Build alerts for menu items with margin compression"
    depends_on:
      - N17_menu_cost
    inputs:
      - menu_cost_facts
    outputs:
      - name: margin_alerts
        type: "MarginAlert[]"
        schema:
          alert_id: uuid
          menu_item_id: uuid
          menu_item_name: string
          cost_spike_amount: decimal
          cost_spike_percent: decimal
          margin_compression: decimal
          current_margin: decimal
          target_margin: decimal
          contributing_ingredients:
            product_id: uuid
            product_name: string
            cost_change: decimal
            contribution_percent: decimal
          recommended_actions: string[]
          reason_codes: string[]
          estimated_impact:
            daily_margin_loss: decimal
            monthly_margin_loss: decimal
          required_approver: string?
          policy_tokens: uuid[]
          created_at: datetime
    invariants:
      - "margin_compression > 0"
      - "reason_codes.length > 0"
    side_effects: none
    cacheable: false
    ttl_seconds: 0

# ============================================================================
# LAYER 4: EXECUTION (N40-N46)
# Explicit approvals only.
# No execution without an approval token.
# ============================================================================

  # --------------------------------------------------------------------------
  # N40: Approval Intake
  # --------------------------------------------------------------------------
  N40_approval_intake:
    layer: 4
    name: "Approval Intake"
    description: "Process signed approval actions from UI/API"
    depends_on: []
    inputs:
      - approval_action
      - user_signature
    outputs:
      - name: approval_token
        type: "ApprovalToken"
        schema:
          token_id: uuid
          proposal_id: uuid
          proposal_type: string
          approved_by: uuid
          approved_at: datetime
          approval_method: enum[ui, api, auto]
          digital_signature: string
          policy_tokens: uuid[]
          immutable: boolean
    invariants:
      - "immutable == true"
      - "approved_by != null"
      - "digital_signature != null"
    side_effects:
      - "APPEND approval_audit_log"
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N41: Execute Purchase Order
  # --------------------------------------------------------------------------
  N41_execute_po:
    layer: 4
    name: "Execute Purchase Order"
    description: "Submit approved reorder to vendor"
    depends_on:
      - N40_approval_intake
      - N30_reorder_proposal
      - N20_liquidity_gate
    inputs:
      - approval_token
      - reorder_proposals
      - spend_policy
    outputs:
      - name: po_created
        type: "POCreated"
        schema:
          order_id: uuid
          po_number: string
          vendor_id: uuid
          vendor_name: string
          line_items: object[]
          total_amount: decimal
          status: enum[queued, submitted, confirmed]
          eta: datetime
          approval_token_id: uuid
          dispatch_request:
            vendor_api_endpoint: string
            request_body: object
            dispatched_at: datetime?
          created_at: datetime
    invariants:
      - "approval_token != null OR proposal.auto_execute_eligible == true"
      - "spend_policy.allowed == true"
    side_effects:
      - "CREATE order record"
      - "RESERVE ledger funds"
      - "DISPATCH to vendor API"
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N42: Execute Vendor Switch
  # --------------------------------------------------------------------------
  N42_execute_vendor_switch:
    layer: 4
    name: "Execute Vendor Switch"
    description: "Update vendor preference for product"
    depends_on:
      - N40_approval_intake
      - N34_vendor_switch
    inputs:
      - approval_token
      - vendor_switch_proposals
    outputs:
      - name: vendor_switch_executed
        type: "VendorSwitchExecuted"
        schema:
          execution_id: uuid
          product_id: uuid
          from_vendor_id: uuid
          to_vendor_id: uuid
          effective_date: datetime
          approval_token_id: uuid
          contract_update_event: object?
          executed_at: datetime
    invariants:
      - "approval_token != null"
    side_effects:
      - "UPDATE vendor_preference"
      - "LOG switch_audit"
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N43: Execute Transfer
  # --------------------------------------------------------------------------
  N43_execute_transfer:
    layer: 4
    name: "Execute Transfer"
    description: "Create inter-location transfer order"
    depends_on:
      - N40_approval_intake
      - N35_transfer_proposal
    inputs:
      - approval_token
      - transfer_proposals
    outputs:
      - name: transfer_order_created
        type: "TransferOrderCreated"
        schema:
          transfer_id: uuid
          product_id: uuid
          source_location_id: uuid
          dest_location_id: uuid
          quantity: integer
          status: enum[created, in_transit, completed]
          approval_token_id: uuid
          created_at: datetime
    invariants:
      - "approval_token != null"
      - "quantity > 0"
    side_effects:
      - "CREATE transfer_order"
      - "RESERVE source inventory"
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N44: Apply Receiving Adjustments
  # --------------------------------------------------------------------------
  N44_apply_receiving:
    layer: 4
    name: "Apply Receiving Adjustments"
    description: "Close PO with adjustments and update inventory"
    depends_on:
      - N40_approval_intake
      - N32_receiving_adjustment
    inputs:
      - approval_token
      - po_adjustments
    outputs:
      - name: receiving_applied
        type: "ReceivingApplied"
        schema:
          application_id: uuid
          po_id: uuid
          po_number: string
          new_status: enum[received, partially_received, disputed]
          adjustments_applied: object[]
          inventory_corrections: object[]
          approval_token_id: uuid
          applied_at: datetime
    invariants:
      - "approval_token != null"
    side_effects:
      - "UPDATE po.status"
      - "UPDATE inventory levels"
      - "CREATE adjustment records"
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N45: Execute Expiration Actions
  # --------------------------------------------------------------------------
  N45_execute_expiration:
    layer: 4
    name: "Execute Expiration Actions"
    description: "Execute markdown, donation, or disposal actions"
    depends_on:
      - N40_approval_intake
      - N33_expiration_plan
    inputs:
      - approval_token
      - expiry_action_plans
    outputs:
      - name: expiration_executed
        type: "ExpirationExecuted"
        schema:
          execution_id: uuid
          plan_id: uuid
          actions_executed:
            action_type: string
            quantity: integer
            result: object
          discount_markdown: object?
          donation_manifest: object?
          disposal_record: object?
          approval_token_id: uuid
          executed_at: datetime
    invariants:
      - "approval_token != null"
    side_effects:
      - "UPDATE inventory (markdown/remove)"
      - "CREATE donation manifest"
      - "CREATE disposal record"
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N46: Waste Autopsy Enforcement
  # --------------------------------------------------------------------------
  N46_waste_autopsy:
    layer: 4
    name: "Waste Autopsy Enforcement"
    description: "Strict waste logging protocol with evidence hash"
    depends_on:
      - N45_execute_expiration
    inputs:
      - disposal_events
      - loss_events
    outputs:
      - name: waste_log
        type: "WasteLog"
        schema:
          log_id: uuid
          event_type: enum[spoilage, damage, theft, disposal, donation]
          product_id: uuid
          quantity: integer
          value: decimal
          root_cause: string
          evidence_hash: string?
          photos_attached: boolean
          witness_id: uuid?
          protocol_followed: boolean
          created_at: datetime
    invariants:
      - "root_cause != null"
      - "protocol_followed == true"
    side_effects:
      - "CREATE waste_audit_record"
    cacheable: false
    ttl_seconds: 0

# ============================================================================
# LAYER 5: TELEMETRY (N50-N52)
# Accounting + Moat Metrics
# Every action emits: decision_trace_id, inputs_version_hash,
# policy_token_id, approval_token_id, hours-saved estimate
# ============================================================================

  # --------------------------------------------------------------------------
  # N50: Ledger Posting
  # --------------------------------------------------------------------------
  N50_ledger_posting:
    layer: 5
    name: "Ledger Posting"
    description: "Double-entry postings for costs, recoveries, variances"
    depends_on:
      - N41_execute_po
      - N44_apply_receiving
      - N45_execute_expiration
    inputs:
      - po_created
      - receiving_applied
      - expiration_executed
    outputs:
      - name: ledger_postings
        type: "LedgerPosting[]"
        schema:
          posting_id: uuid
          posting_type: enum[cost, recovery, variance, markdown, disposal]
          debit_account: string
          credit_account: string
          amount: decimal
          reference_id: uuid
          reference_type: string
          description: string
          posted_at: datetime
    invariants:
      - "debit_account != credit_account"
      - "amount > 0"
    side_effects:
      - "POST to Ledger system"
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N51: Efficiency Counter
  # --------------------------------------------------------------------------
  N51_efficiency_metrics:
    layer: 5
    name: "Efficiency Counter"
    description: "Track human hours saved by Bishop automation"
    depends_on:
      - N41_execute_po
      - N42_execute_vendor_switch
      - N43_execute_transfer
      - N44_apply_receiving
      - N45_execute_expiration
    inputs:
      - completed_workflows
    outputs:
      - name: efficiency_events
        type: "EfficiencyEvent[]"
        schema:
          event_id: uuid
          workflow_type: string
          workflow_id: uuid
          human_hours_saved: decimal
          calculation_method: string
          baseline_manual_minutes: integer
          actual_bishop_seconds: integer
          savings_percent: decimal
          recorded_at: datetime
    invariants:
      - "human_hours_saved >= 0"
      - "savings_percent >= 0 AND savings_percent <= 100"
    side_effects:
      - "INCREMENT efficiency_counters"
    cacheable: false
    ttl_seconds: 0

  # --------------------------------------------------------------------------
  # N52: Audit Trail Compiler
  # --------------------------------------------------------------------------
  N52_audit_trail:
    layer: 5
    name: "Audit Trail Compiler"
    description: "Immutable 'Why Bishop did this' narrative log"
    depends_on: []
    inputs:
      - all_node_outputs
    outputs:
      - name: audit_entries
        type: "AuditEntry[]"
        schema:
          entry_id: uuid
          decision_trace_id: uuid
          node_id: string
          node_name: string
          inputs_version_hash: string
          outputs_version_hash: string
          policy_token_ids: uuid[]
          approval_token_id: uuid?
          human_readable_narrative: string
          hours_saved_estimate: decimal
          timestamp: datetime
          immutable: boolean
    invariants:
      - "immutable == true"
      - "decision_trace_id != null"
      - "inputs_version_hash != null"
    side_effects:
      - "APPEND audit_log (immutable)"
    cacheable: false
    ttl_seconds: 0

# ============================================================================
# EXECUTION POLICIES
# ============================================================================

policies:
  auto_execution:
    description: "Conditions for automatic execution without user approval"
    rules:
      - "confidence >= 0.85"
      - "severity == 'critical'"
      - "spend_policy.allowed == true"
      - "total_cost <= auto_approve_threshold"
    excluded_nodes:
      - N44_apply_receiving
      - N42_execute_vendor_switch
      - N46_waste_autopsy

  cache_invalidation:
    description: "When to invalidate cached node outputs"
    triggers:
      - "new scan_event"
      - "inventory adjustment"
      - "po status change"
      - "vendor price update"
      - "lot expiry change"

  confidence_thresholds:
    warning_only: 0.6
    proposal_eligible: 0.75
    auto_execute_eligible: 0.85

# ============================================================================
# BISHOP LOOP (Runtime Schedule)
# ============================================================================

runtime:
  on_scan_event:
    description: "Triggered on every scan event"
    sequence:
      - N2_scan_normalization
      - N10_demand_forecast
      - N11_stockout_risk
      - N12_ghost_inventory
      - N15_scan_anomaly
      - N16_receiving_reconciliation
      - N25_priority_scoring
    max_latency_ms: 500

  hourly:
    description: "Scheduled hourly refresh"
    sequence:
      - N1_inventory_snapshot
      - N10_demand_forecast
      - N11_stockout_risk
      - N13_expiration_risk
      - N14_price_delta
      - N18_location_imbalance
      - N25_priority_scoring

  daily:
    description: "Scheduled daily refresh"
    sequence:
      - N3_sku_normalization
      - N17_menu_cost
      - N15_scan_anomaly  # baseline recalculation

# ============================================================================
# DEFINITION OF DONE (Per Layer)
# ============================================================================

definition_of_done:
  layer_0:
    - "All outputs are versioned, typed, and reproducible from DB rows"
    - "Every downstream node references these outputs ONLY"
    - "No direct table access (no 'spelunking')"
    - "Schema changes require migration"

  layer_1:
    - "Signals are idempotent (same inputs ⇒ same outputs)"
    - "No node can create orders, transfers, or ledger entries"
    - "Confidence scores are calibrated and documented"
    - "All thresholds are configurable"

  layer_2:
    - "All 'should we do it?' decisions happen here"
    - "Every action downstream references a policy decision token"
    - "Policy changes are audited"
    - "No business logic leaks to other layers"

  layer_3:
    - "Outputs are 'ready-to-approve' with complete payloads"
    - "Every proposal includes: reason_codes[], estimated_impact, required_approver"
    - "No side effects"
    - "Proposals are traceable to source signals"

  layer_4:
    - "No execution without approval_token (except explicit auto-exec policy)"
    - "All side effects are declared and logged"
    - "Rollback procedures documented"
    - "Execution is atomic"

  layer_5:
    - "Every action emits: decision_trace_id, inputs_version_hash, policy_token_id, approval_token_id, hours-saved estimate"
    - "Audit trail is immutable"
    - "Metrics are aggregatable"
    - "Ledger postings are double-entry balanced"

# ============================================================================
# VALIDATION RULES
# ============================================================================

validation:
  on_startup:
    - "All declared nodes must have corresponding module"
    - "All dependencies must exist"
    - "No circular dependencies"
    - "All outputs must have schema"
    - "Layer ordering is respected (deps only point down)"

  on_execution:
    - "Inputs must be available before execution"
    - "Outputs must match declared schema"
    - "Invariants must hold"
    - "Side effects must match declaration"
    - "Policy tokens must be valid"

  on_deployment:
    - "All DoD criteria met per layer"
    - "Integration tests pass"
    - "Mermaid diagram regenerated"
    - "Schema migrations applied"
