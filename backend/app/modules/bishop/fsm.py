"""
PROVENIQ Ops - Bishop FSM (Finite State Machine)
Phase 0-1: Telemetry → Bishop → Recommendation → Accepted Event Pipeline

STATE MACHINE:
    IDLE → SCANNING → ANALYZING_RISK → CHECKING_FUNDS → ORDER_QUEUED → IDLE

CRITICAL GOVERNANCE RULES:
- AI NEVER auto-acts without acceptance
- Every state transition is logged
- Every recommendation requires human accept/reject/modify
- All accepted events become forensic history
"""

import uuid
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional, Callable, Awaitable
from pydantic import BaseModel, Field
import logging

from app.services.events.store import event_store

logger = logging.getLogger(__name__)


class BishopState(str, Enum):
    """Bishop FSM States"""
    IDLE = "IDLE"
    SCANNING = "SCANNING"
    ANALYZING_RISK = "ANALYZING_RISK"
    CHECKING_FUNDS = "CHECKING_FUNDS"
    ORDER_QUEUED = "ORDER_QUEUED"
    AWAITING_APPROVAL = "AWAITING_APPROVAL"
    EXECUTING = "EXECUTING"
    ERROR = "ERROR"


class RecommendationType(str, Enum):
    """Types of recommendations Bishop can generate"""
    REORDER = "reorder"
    ADJUST_PAR = "adjust_par"
    FLAG_SHRINKAGE = "flag_shrinkage"
    SWITCH_VENDOR = "switch_vendor"
    DEFER_ORDER = "defer_order"
    EXPEDITE_ORDER = "expedite_order"
    DISPOSE_EXPIRED = "dispose_expired"


class RecommendationStatus(str, Enum):
    """Status of a Bishop recommendation"""
    PENDING = "pending"           # Awaiting human decision
    ACCEPTED = "accepted"         # Human accepted as-is
    MODIFIED = "modified"         # Human modified and accepted
    REJECTED = "rejected"         # Human rejected
    EXPIRED = "expired"           # Timed out without decision
    AUTO_APPROVED = "auto_approved"  # Below threshold, auto-approved (still logged)


class BishopRecommendation(BaseModel):
    """
    A recommendation generated by Bishop.
    
    GOVERNANCE: Recommendations MUST be accepted/rejected by humans.
    Bishop NEVER auto-executes above configurable thresholds.
    """
    recommendation_id: uuid.UUID = Field(default_factory=uuid.uuid4)
    recommendation_type: RecommendationType
    
    # What Bishop recommends
    product_id: uuid.UUID
    product_name: str
    location_id: uuid.UUID
    
    # Recommendation details
    recommended_quantity: int
    recommended_vendor_id: Optional[uuid.UUID] = None
    recommended_vendor_name: Optional[str] = None
    estimated_cost_micros: int = 0
    
    # Bishop's confidence and reasoning
    confidence: Decimal = Field(ge=0, le=1)
    reason_codes: List[str] = []
    explanation: str = ""
    
    # Context that led to this recommendation (forensic value)
    trigger_context: Dict[str, Any] = {}
    
    # Status tracking
    status: RecommendationStatus = RecommendationStatus.PENDING
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    decided_at: Optional[datetime] = None
    decided_by: Optional[uuid.UUID] = None
    
    # If modified, what was changed
    modified_quantity: Optional[int] = None
    modified_vendor_id: Optional[uuid.UUID] = None
    modification_reason: Optional[str] = None
    
    # Correlation for tracing
    correlation_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    trace_id: Optional[uuid.UUID] = None


class StateTransition(BaseModel):
    """Record of a state transition (forensic history)"""
    transition_id: uuid.UUID = Field(default_factory=uuid.uuid4)
    previous_state: Optional[BishopState]
    new_state: BishopState
    trigger_event: str
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    context_data: Dict[str, Any] = {}
    session_id: uuid.UUID
    correlation_id: str


class BishopSession(BaseModel):
    """
    A Bishop session represents one scan-to-order cycle.
    
    All state transitions and recommendations within a session are linked
    for forensic reconstruction.
    """
    session_id: uuid.UUID = Field(default_factory=uuid.uuid4)
    org_id: uuid.UUID
    location_id: uuid.UUID
    initiated_by: Optional[uuid.UUID] = None
    
    # Current state
    state: BishopState = BishopState.IDLE
    
    # Session timeline
    started_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    completed_at: Optional[datetime] = None
    
    # State history (for forensics)
    transitions: List[StateTransition] = []
    
    # Recommendations generated in this session
    recommendations: List[BishopRecommendation] = []
    
    # Scan results
    scan_results: Dict[str, Any] = {}
    
    # Risk analysis results
    risk_analysis: Dict[str, Any] = {}
    
    # Funds check results  
    funds_check: Dict[str, Any] = {}
    
    # Correlation
    correlation_id: str = Field(default_factory=lambda: str(uuid.uuid4()))


class BishopFSM:
    """
    Bishop Finite State Machine
    
    GOVERNANCE COMPLIANCE:
    - Every state transition is persisted to ops_events
    - Every recommendation requires human decision (no auto-execute above threshold)
    - All context is preserved for forensic reconstruction
    - After months of use, this history creates DATA GRAVITY
    """
    
    # Auto-approval threshold (micros) - orders below this can auto-approve
    # but are STILL logged for audit trail
    AUTO_APPROVAL_THRESHOLD_MICROS = 50_000_000  # $50
    
    def __init__(self):
        self._active_sessions: Dict[uuid.UUID, BishopSession] = {}
    
    async def start_session(
        self,
        org_id: uuid.UUID,
        location_id: uuid.UUID,
        initiated_by: Optional[uuid.UUID] = None,
    ) -> BishopSession:
        """
        Start a new Bishop session.
        
        Returns a session that can be used to track the scan-to-order cycle.
        """
        session = BishopSession(
            org_id=org_id,
            location_id=location_id,
            initiated_by=initiated_by,
        )
        
        self._active_sessions[session.session_id] = session
        
        # Log session start event
        await event_store.append(
            event_type="ops.bishop.session_started",
            payload={
                "session_id": str(session.session_id),
                "org_id": str(org_id),
                "location_id": str(location_id),
                "initiated_by": str(initiated_by) if initiated_by else None,
            },
            correlation_id=session.correlation_id,
        )
        
        logger.info(f"Bishop session started: {session.session_id}")
        return session
    
    async def transition(
        self,
        session_id: uuid.UUID,
        new_state: BishopState,
        trigger_event: str,
        context_data: Optional[Dict[str, Any]] = None,
    ) -> StateTransition:
        """
        Transition to a new state.
        
        Every transition is:
        1. Validated (only allowed transitions)
        2. Logged to persistent event store
        3. Added to session history
        """
        session = self._active_sessions.get(session_id)
        if not session:
            raise ValueError(f"Session {session_id} not found")
        
        # Validate transition
        if not self._is_valid_transition(session.state, new_state):
            raise ValueError(f"Invalid transition: {session.state} → {new_state}")
        
        previous_state = session.state
        
        # Create transition record
        transition = StateTransition(
            previous_state=previous_state,
            new_state=new_state,
            trigger_event=trigger_event,
            context_data=context_data or {},
            session_id=session_id,
            correlation_id=session.correlation_id,
        )
        
        # Update session state
        session.state = new_state
        session.transitions.append(transition)
        
        # Persist to event store (DATA GRAVITY)
        await event_store.append(
            event_type="ops.bishop.state_transition",
            payload={
                "session_id": str(session_id),
                "transition_id": str(transition.transition_id),
                "previous_state": previous_state.value if previous_state else None,
                "new_state": new_state.value,
                "trigger_event": trigger_event,
                "context_data": context_data or {},
            },
            correlation_id=session.correlation_id,
        )
        
        logger.info(f"Bishop transition: {previous_state} → {new_state} ({trigger_event})")
        return transition
    
    def _is_valid_transition(self, current: BishopState, target: BishopState) -> bool:
        """Check if a state transition is valid."""
        valid_transitions = {
            BishopState.IDLE: [BishopState.SCANNING, BishopState.ERROR],
            BishopState.SCANNING: [BishopState.ANALYZING_RISK, BishopState.IDLE, BishopState.ERROR],
            BishopState.ANALYZING_RISK: [BishopState.CHECKING_FUNDS, BishopState.AWAITING_APPROVAL, BishopState.IDLE, BishopState.ERROR],
            BishopState.CHECKING_FUNDS: [BishopState.ORDER_QUEUED, BishopState.AWAITING_APPROVAL, BishopState.IDLE, BishopState.ERROR],
            BishopState.AWAITING_APPROVAL: [BishopState.EXECUTING, BishopState.IDLE, BishopState.ERROR],
            BishopState.ORDER_QUEUED: [BishopState.EXECUTING, BishopState.AWAITING_APPROVAL, BishopState.IDLE, BishopState.ERROR],
            BishopState.EXECUTING: [BishopState.IDLE, BishopState.ERROR],
            BishopState.ERROR: [BishopState.IDLE],
        }
        return target in valid_transitions.get(current, [])
    
    async def generate_recommendation(
        self,
        session_id: uuid.UUID,
        recommendation_type: RecommendationType,
        product_id: uuid.UUID,
        product_name: str,
        recommended_quantity: int,
        confidence: Decimal,
        reason_codes: List[str],
        explanation: str,
        estimated_cost_micros: int = 0,
        recommended_vendor_id: Optional[uuid.UUID] = None,
        recommended_vendor_name: Optional[str] = None,
        trigger_context: Optional[Dict[str, Any]] = None,
    ) -> BishopRecommendation:
        """
        Generate a recommendation.
        
        GOVERNANCE: This does NOT execute anything.
        It creates a recommendation that MUST be accepted/rejected by a human.
        """
        session = self._active_sessions.get(session_id)
        if not session:
            raise ValueError(f"Session {session_id} not found")
        
        recommendation = BishopRecommendation(
            recommendation_type=recommendation_type,
            product_id=product_id,
            product_name=product_name,
            location_id=session.location_id,
            recommended_quantity=recommended_quantity,
            recommended_vendor_id=recommended_vendor_id,
            recommended_vendor_name=recommended_vendor_name,
            estimated_cost_micros=estimated_cost_micros,
            confidence=confidence,
            reason_codes=reason_codes,
            explanation=explanation,
            trigger_context=trigger_context or {},
            correlation_id=session.correlation_id,
        )
        
        session.recommendations.append(recommendation)
        
        # Persist recommendation event
        await event_store.append(
            event_type="ops.bishop.recommendation_generated",
            payload={
                "session_id": str(session_id),
                "recommendation_id": str(recommendation.recommendation_id),
                "recommendation_type": recommendation_type.value,
                "product_id": str(product_id),
                "product_name": product_name,
                "recommended_quantity": recommended_quantity,
                "estimated_cost_micros": estimated_cost_micros,
                "confidence": str(confidence),
                "reason_codes": reason_codes,
                "explanation": explanation,
                "trigger_context": trigger_context or {},
            },
            correlation_id=session.correlation_id,
        )
        
        logger.info(f"Bishop recommendation generated: {recommendation.recommendation_id} ({recommendation_type})")
        return recommendation
    
    async def accept_recommendation(
        self,
        session_id: uuid.UUID,
        recommendation_id: uuid.UUID,
        accepted_by: uuid.UUID,
        modified_quantity: Optional[int] = None,
        modified_vendor_id: Optional[uuid.UUID] = None,
        modification_reason: Optional[str] = None,
    ) -> BishopRecommendation:
        """
        Accept a recommendation (possibly with modifications).
        
        This is the human-in-the-loop that creates the ACCEPTED EVENT.
        This event becomes part of the forensic history.
        """
        session = self._active_sessions.get(session_id)
        if not session:
            raise ValueError(f"Session {session_id} not found")
        
        recommendation = next(
            (r for r in session.recommendations if r.recommendation_id == recommendation_id),
            None
        )
        if not recommendation:
            raise ValueError(f"Recommendation {recommendation_id} not found")
        
        if recommendation.status != RecommendationStatus.PENDING:
            raise ValueError(f"Recommendation already has status: {recommendation.status}")
        
        # Determine if modified
        is_modified = modified_quantity is not None or modified_vendor_id is not None
        
        recommendation.status = RecommendationStatus.MODIFIED if is_modified else RecommendationStatus.ACCEPTED
        recommendation.decided_at = datetime.now(timezone.utc)
        recommendation.decided_by = accepted_by
        recommendation.modified_quantity = modified_quantity
        recommendation.modified_vendor_id = modified_vendor_id
        recommendation.modification_reason = modification_reason
        
        # Persist ACCEPTED EVENT (this is the forensic record)
        await event_store.append(
            event_type="ops.bishop.recommendation_accepted",
            payload={
                "session_id": str(session_id),
                "recommendation_id": str(recommendation_id),
                "accepted_by": str(accepted_by),
                "original_quantity": recommendation.recommended_quantity,
                "final_quantity": modified_quantity or recommendation.recommended_quantity,
                "original_vendor_id": str(recommendation.recommended_vendor_id) if recommendation.recommended_vendor_id else None,
                "final_vendor_id": str(modified_vendor_id) if modified_vendor_id else (str(recommendation.recommended_vendor_id) if recommendation.recommended_vendor_id else None),
                "was_modified": is_modified,
                "modification_reason": modification_reason,
                "estimated_cost_micros": recommendation.estimated_cost_micros,
            },
            correlation_id=session.correlation_id,
        )
        
        logger.info(f"Recommendation {recommendation_id} accepted by {accepted_by} (modified={is_modified})")
        return recommendation
    
    async def reject_recommendation(
        self,
        session_id: uuid.UUID,
        recommendation_id: uuid.UUID,
        rejected_by: uuid.UUID,
        rejection_reason: str,
    ) -> BishopRecommendation:
        """
        Reject a recommendation.
        
        Rejections are logged for ML training - understanding WHY humans
        reject Bishop's recommendations improves future accuracy.
        """
        session = self._active_sessions.get(session_id)
        if not session:
            raise ValueError(f"Session {session_id} not found")
        
        recommendation = next(
            (r for r in session.recommendations if r.recommendation_id == recommendation_id),
            None
        )
        if not recommendation:
            raise ValueError(f"Recommendation {recommendation_id} not found")
        
        recommendation.status = RecommendationStatus.REJECTED
        recommendation.decided_at = datetime.now(timezone.utc)
        recommendation.decided_by = rejected_by
        recommendation.modification_reason = rejection_reason
        
        # Persist rejection event (ML training data)
        await event_store.append(
            event_type="ops.bishop.recommendation_rejected",
            payload={
                "session_id": str(session_id),
                "recommendation_id": str(recommendation_id),
                "rejected_by": str(rejected_by),
                "rejection_reason": rejection_reason,
                "original_recommendation": {
                    "type": recommendation.recommendation_type.value,
                    "quantity": recommendation.recommended_quantity,
                    "confidence": str(recommendation.confidence),
                    "reason_codes": recommendation.reason_codes,
                },
            },
            correlation_id=session.correlation_id,
        )
        
        logger.info(f"Recommendation {recommendation_id} rejected by {rejected_by}: {rejection_reason}")
        return recommendation
    
    async def complete_session(
        self,
        session_id: uuid.UUID,
    ) -> BishopSession:
        """
        Complete a Bishop session.
        
        The complete session with all transitions and recommendations
        becomes part of the permanent forensic record.
        """
        session = self._active_sessions.get(session_id)
        if not session:
            raise ValueError(f"Session {session_id} not found")
        
        session.completed_at = datetime.now(timezone.utc)
        
        # Final state should be IDLE
        if session.state != BishopState.IDLE:
            await self.transition(session_id, BishopState.IDLE, "session_completed")
        
        # Persist session completion
        await event_store.append(
            event_type="ops.bishop.session_completed",
            payload={
                "session_id": str(session_id),
                "org_id": str(session.org_id),
                "location_id": str(session.location_id),
                "duration_seconds": (session.completed_at - session.started_at).total_seconds(),
                "transition_count": len(session.transitions),
                "recommendation_count": len(session.recommendations),
                "accepted_count": sum(1 for r in session.recommendations if r.status in [RecommendationStatus.ACCEPTED, RecommendationStatus.MODIFIED]),
                "rejected_count": sum(1 for r in session.recommendations if r.status == RecommendationStatus.REJECTED),
            },
            correlation_id=session.correlation_id,
        )
        
        # Remove from active sessions
        del self._active_sessions[session_id]
        
        logger.info(f"Bishop session completed: {session_id}")
        return session
    
    def get_session(self, session_id: uuid.UUID) -> Optional[BishopSession]:
        """Get an active session."""
        return self._active_sessions.get(session_id)
    
    def get_active_sessions(self, org_id: Optional[uuid.UUID] = None) -> List[BishopSession]:
        """Get all active sessions, optionally filtered by org."""
        sessions = list(self._active_sessions.values())
        if org_id:
            sessions = [s for s in sessions if s.org_id == org_id]
        return sessions


# Singleton instance
bishop_fsm = BishopFSM()
